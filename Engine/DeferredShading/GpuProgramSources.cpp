#pragma once

#include "GpuProgramSources.h"

std::string GpuProgramSources::ambientVs =
		"#version 150\n"
		"\n"
		"in vec4 vertex;\n"
		"\n"
		"out vec2 oUv0;\n"
		"out vec3 oRay;\n"
		"\n"
		"uniform vec3 farCorner;\n"
		"uniform float flip;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	// Clean up inaccuracies\n"
		"	vec2 Pos = sign(vertex.xy);\n"
		"\n"
		"	// Image-space\n"
		"	oUv0 = (vec2(Pos.x, -Pos.y) + 1.0) * 0.5;\n"
		"\n"
		"	// This ray will be interpolated and will be the ray from the camera\n"
		"	// to the far clip plane, per pixel\n"
		"	oRay = farCorner * vec3(Pos, 1.0);\n"
		"\n"
		"	gl_Position = vec4(Pos, 0.0, 1.0);\n"
		"	gl_Position.y *= flip;\n"
		"}";

std::string GpuProgramSources::ambientPs =
		"#version 150\n"
		"\n"
		"in vec2 oUv0;\n"
		"in vec3 oRay;\n"
		"\n"
		"out vec4 oColour;\n"
		"\n"
		"uniform sampler2D Tex0;\n"
		"uniform sampler2D Tex1;\n"
		"uniform sampler2D Tex2;\n"
		"uniform sampler2D Tex3;\n"
		"uniform sampler2D Tex4;\n"
		"uniform mat4 proj;\n"
		"uniform vec4 ambientColor;\n"
		"uniform float farClipDistance;\n"
		"\n"
		"float finalDepth(vec4 p)\n"
		"{\n"
		"	// GL needs it in [0..1]\n"
		"	return (p.z / p.w) * 0.5 + 0.5;\n"
		"}\n"
		"\n"
		"void main()\n"
		"{\n"
		"	vec4 a0 = texture(Tex0, oUv0); // Attribute 0: Diffuse color+shininess\n"
		"	vec4 a1 = texture(Tex1, oUv0); // Attribute 1: Normal+depth\n"
		"	vec4 a2 = texture(Tex2, oUv0); // Attribute 2: Lightmap\n"
		"	vec4 a3 = texture(Tex3, oUv0); // Attribute 3: Emissive map\n"
		"	vec4 a4 = texture(Tex4, oUv0); // Attribute 4: View pos map\n"
		"\n"
		"	// Clip fragment if depth is too close, so the skybox can be rendered on the background\n"
		"	if (a1.w == 0.0)\n"
		"		discard;\n"
		"\n"
		"	// Calculate ambient colour of fragment\n"
		"	oColour = vec4((ambientColor + a2) * vec4(a0.rgb, 0));\n"
		"\n"
		"	vec3 emissive = a3.rgb * a3.a;\n"
		"	oColour += vec4(emissive, 0.0);\n"
		"\n"
		"	// Calculate depth of fragment;\n"
		"	vec3 viewPos = normalize(oRay) * farClipDistance * a1.w;\n"
		"	vec4 projPos = proj * vec4(viewPos, 1.0);\n"
		"	gl_FragDepth = finalDepth(projPos);\n"
		"}";

std::string GpuProgramSources::shadowCasterVs =
		"#version 120\n"
		"\n"
		"uniform mat4 cWorldViewProj;\n"
		"uniform mat4 cWorldView;\n"
		"uniform vec4 texelOffsets;\n"
		"\n"
		"attribute vec4 vertex;\n"
		"attribute vec2 uv0;\n"
		"\n"
		"varying vec3 oViewPos;\n"
		"varying vec2 depth;\n"
		"varying vec2 oUv0;\n"
		"\n"
		"void main()\n"
		"{\n"
		"    gl_Position = cWorldViewProj * vertex;\n"
		"    oViewPos = (cWorldView * vertex).xyz;\n"
		"    oUv0 = uv0;\n"
		"\n"
		"    vec4 outPos = cWorldViewProj * vertex;\n"
		"    outPos.xy += texelOffsets.zw * outPos.w;\n"
		"    depth = outPos.zw;\n"
		"}";

std::string GpuProgramSources::shadowCasterFs =
		"#version 120\n"
		"\n"
		"uniform float cFarDistance;\n"
		"uniform int lightType;\n"
		"uniform sampler2D diffuseTexture;\n"
		"\n"
		"varying vec3 oViewPos;\n"
		"varying vec2 depth;\n"
		"varying vec2 oUv0;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	vec4 color = texture2D(diffuseTexture, oUv0);\n"
		"\n"
		"	if (color.a < 0.25)\n"
		"		discard;\n"
		"\n"
		"	if (lightType == 0)\n"
		"	{\n"
		"		float depthDir = depth.x / depth.y;\n"
		"		gl_FragColor = vec4(depthDir, depthDir, depthDir, 1.0);\n"
		"	}\n"
		"\n"
		"	if (lightType == 1)\n"
		"	{\n"
		"		float depthDir = depth.x / depth.y;\n"
		"		gl_FragColor = vec4(depthDir, depthDir, depthDir, 1.0);\n"
		"	}\n"
		"\n"
		"	if (lightType == 2)\n"
		"	{\n"
		"		float depthCube = length(oViewPos) / 1000.0;\n"
		"		gl_FragColor = vec4(depthCube, depthCube, depthCube, 1.0);\n"
		"	}\n"
		"}";

std::string GpuProgramSources::lightVs =
		"#version 150\n"
		"\n"
		"in vec4 vertex;\n"
		"\n"
		"out vec4 oPos;\n"
		"out vec2 oUv0;\n"
		"\n"
		"uniform mat4 worldViewProj;\n"
		"uniform mat4 world;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	gl_Position = worldViewProj * vertex;\n"
		"	oPos = gl_Position;\n"
		"	oUv0 = gl_Position.xy;\n"
		"}";

std::string GpuProgramSources::lightFs =
		"#define LIGHT_POINT         1\n"
		"#define LIGHT_SPOT          2\n"
		"#define LIGHT_DIRECTIONAL   3\n"
		"\n"
		"#version 150\n"
		"\n"
		"#if LIGHT_TYPE == LIGHT_DIRECTIONAL\n"
		"in vec2 oUv0;\n"
		"in vec3 oRay;\n"
		"#endif\n"
		"\n"
		"in vec4 oPos;\n"
		"\n"
		"uniform sampler2D Tex0;\n"
		"uniform sampler2D Tex1;\n"
		"\n"
		"#ifdef HAS_EMISSIVEMAP\n"
		"uniform sampler2D u_EmissiveSampler;\n"
		"#endif\n"
		"\n"
		"uniform sampler2D u_MetallicRoughnessSampler;\n"
		"\n"
		"#ifdef HAS_OCCLUSIONMAP\n"
		"uniform sampler2D u_OcclusionSampler;\n"
		"#endif\n"
		"\n"
		"#ifdef USE_IBL\n"
		"uniform sampler2D u_DiffuseEnvSampler;\n"
		"#endif\n"
		"\n"
		"uniform sampler2D u_ViewPos;\n"
		"uniform sampler2D u_LightMap;\n"
		"\n"
		"uniform int lightMode;\n"
		"uniform float shadowBias;\n"
		"\n"
		"uniform vec2 u_MetallicRoughnessValues;\n"
		"uniform vec4 u_BaseColorFactor;\n"
		"\n"
		"uniform vec3 u_Camera;\n"
		"\n"
		"uniform float shadowAASamples;\n"
		"uniform int shadowCascadesCount;\n"
		"\n"
		"#if LIGHT_TYPE != LIGHT_POINT\n"
		"uniform vec3 lightDir;\n"
		"#endif\n"
		"\n"
		"#if LIGHT_TYPE == LIGHT_SPOT\n"
		"uniform vec4 spotParams;\n"
		"#endif\n"
		"\n"
		"#if LIGHT_TYPE != LIGHT_DIRECTIONAL\n"
		"uniform float vpWidth;\n"
		"uniform float vpHeight;\n"
		"uniform vec3 farCorner;\n"
		"uniform float flip;\n"
		"#endif\n"
		"\n"
		"#ifdef IS_SHADOW_CASTER\n"
		"uniform mat4 invView;\n"
		"uniform mat4 shadowViewProjMat;\n"
		"#if LIGHT_TYPE == LIGHT_POINT\n"
		"uniform samplerCube ShadowTex;\n"
		"#endif\n"
		"#if LIGHT_TYPE == LIGHT_SPOT\n"
		"uniform sampler2D ShadowTex;\n"
		"#endif\n"
		"#if LIGHT_TYPE == LIGHT_DIRECTIONAL\n"
		"uniform sampler2D ShadowTex0;\n"
		"uniform sampler2D ShadowTex1;\n"
		"uniform sampler2D ShadowTex2;\n"
		"uniform sampler2D ShadowTex3;\n"
		"uniform vec4 texMatrixScaleBias1;\n"
		"uniform vec4 texMatrixScaleBias2;\n"
		"uniform vec4 texMatrixScaleBias3;\n"
		"#endif\n"
		"uniform vec3 shadowCamPos;\n"
		"uniform float shadowFarClip;\n"
		"#endif\n"
		"\n"
		"uniform float farClipDistance;\n"
		"uniform float nearClipDistance;\n"
		"\n"
		"// Attributes of light\n"
		"uniform vec4 lightDiffuseColor;\n"
		"uniform vec4 lightSpecularColor;\n"
		"uniform vec4 lightFalloff;\n"
		"uniform vec4 lightPos;\n"
		"uniform vec4 lightPosWorld;\n"
		"uniform float lightPower;\n"
		"\n"
		"#ifdef IS_SHADOW_CASTER\n"
		"#if LIGHT_TYPE != LIGHT_DIRECTIONAL\n"
		"float shadowmapSize = 0.001;\n"
		"float inverseShadowmapSize = 0.0009765625;\n"
		"float fixedDepthBias = shadowBias;\n"
		"float gradientScaleBias = 0.0;\n"
		"#else\n"
		"vec4 shadowMapSize = vec4(0.001, 0.001, 0.001, 0.001);\n"
		"vec4 invShadowMapSize = vec4(0.0009765625, 0.0009765625, 0.0009765625, 0.0009765625);\n"
		"vec4 fixedDepthBias = vec4(0.0002, 0.0005, 0.00075, 0.001) + vec4(shadowBias);\n"
		"vec4 gradientScaleBias = vec4(0.0, 0.0, 0.0, 0.0);\n"
		"#endif\n"
		"#endif\n"
		"\n"
		"out vec4 fragColour;\n"
		"\n"
		"vec3 expand(vec4 v)\n"
		"{\n"
		"	return (v.xyz - 0.5) * 2.0;\n"
		"}\n"
		"\n"
		"#if LIGHT_TYPE == LIGHT_DIRECTIONAL\n"
		"#ifdef IS_SHADOW_CASTER\n"
		"\n"
		"float getShadowFactor\n"
		"(\n"
		"	sampler2D shadowMapUnit,\n"
		"	vec4 lightSpacePos,\n"
		"	float shadowmapSize,\n"
		"	float inverseShadowmapSize,\n"
		"	float fixedDepthBias,\n"
		"	float gradientScaleBias,\n"
		"	float shadowLightDotLN\n"
		")\n"
		"{\n"
		"	// point on shadowmap\n"
		"	float depthAdjust = fixedDepthBias + (1.0 - abs(shadowLightDotLN)) * gradientScaleBias;\n"
		"	lightSpacePos.z -= depthAdjust; // lightSpacePos.z contains lightspace position of current object\n"
		"\n"
		"	float shadow = 0.0;\n"
		"	float samples = shadowAASamples;\n"
		"	float offset = 0.1;\n"
		"\n"
		"	for (float x = -offset; x < offset; x += offset / (samples * 0.5))\n"
		"	{\n"
		"		for (float y = -offset; y < offset; y += offset / (samples * 0.5))\n"
		"		{\n"
		"			vec4 shadowData = texture(shadowMapUnit, lightSpacePos.xy + vec2(x, y) * 0.0075);\n"
		"			float sampledDistance = shadowData.r;\n"
		"\n"
		"			shadow += (shadowData.x + fixedDepthBias > lightSpacePos.z) ? 1.0 : 0.0;\n"
		"		}\n"
		"	}\n"
		"	shadow /= (samples * samples);\n"
		"\n"
		"	// Hack to prevent these getting optimized out, thereby preventing OGRE errors\n"
		"	shadow += 0.001 * (0.001 * shadowmapSize + inverseShadowmapSize);\n"
		"\n"
		"	// Get the average\n"
		"	return shadow;\n"
		"}\n"
		"\n"
		"float getCsmShadowFactor\n"
		"(\n"
		"	sampler2D shadowTexture0,\n"
		"	sampler2D shadowTexture1,\n"
		"	sampler2D shadowTexture2,\n"
		"	sampler2D shadowTexture3,\n"
		"	vec4 lightSpacePos0,\n"
		"	float shadowLightDotLN\n"
		")\n"
		"{\n"
		"	float factor = 1;\n"
		"\n"
		"	if (lightSpacePos0.x > 0.01 && lightSpacePos0.y > 0.01 && lightSpacePos0.x < 0.99 && lightSpacePos0.y < 0.99)\n"
		"	{\n"
		"		factor = getShadowFactor(shadowTexture0, lightSpacePos0, shadowMapSize.x, invShadowMapSize.x,\n"
		"			fixedDepthBias.x, gradientScaleBias.x, shadowLightDotLN);\n"
		"\n"
		"#ifdef CASCADE_BLENDING\n"
		"		vec4 lightSpacePos1;\n"
		"		lightSpacePos1.xyz = lightSpacePos0.xyz + texMatrixScaleBias1.xyz;\n"
		"		lightSpacePos1.xy *= texMatrixScaleBias1.w;\n"
		"\n"
		"		float blend = getShadowFactor(shadowTexture1, lightSpacePos1, shadowMapSize.y, invShadowMapSize.y,\n"
		"			fixedDepthBias.y, gradientScaleBias.y, shadowLightDotLN);\n"
		"\n"
		"		float weight = clamp((max(abs(lightSpacePos0.x - 0.5), abs(lightSpacePos0.y - 0.5)) - 0.375) * 8, 0.0, 1.0);\n"
		"		factor = mix(factor, blend, weight);\n"
		"#endif\n"
		"	}\n"
		"	else\n"
		"	{\n"
		"		vec4 lightSpacePos1;\n"
		"		lightSpacePos1.xyz = lightSpacePos0.xyz + texMatrixScaleBias1.xyz;\n"
		"		lightSpacePos1.xy *= texMatrixScaleBias1.w;\n"
		"\n"
		"		if (lightSpacePos1.x > 0.01 && lightSpacePos1.y > 0.01 && lightSpacePos1.x < 0.99 && lightSpacePos1.y < 0.99)\n"
		"		{\n"
		"			factor = getShadowFactor(shadowTexture1, lightSpacePos1, shadowMapSize.y, invShadowMapSize.y,\n"
		"				fixedDepthBias.y, gradientScaleBias.y, shadowLightDotLN);\n"
		"\n"
		"#ifdef CASCADE_BLENDING\n"
		"			if (shadowCascadesCount > 2)\n"
		"			{\n"
		"				vec4 lightSpacePos2;\n"
		"				lightSpacePos2.xyz = lightSpacePos0.xyz + texMatrixScaleBias2.xyz;\n"
		"				lightSpacePos2.xy *= texMatrixScaleBias2.w;\n"
		"\n"
		"				float blend = getShadowFactor(shadowTexture2, lightSpacePos2, shadowMapSize.z, invShadowMapSize.z,\n"
		"					fixedDepthBias.z, gradientScaleBias.z, shadowLightDotLN);\n"
		"				float weight = clamp((max(abs(lightSpacePos1.x - 0.5), abs(lightSpacePos1.y - 0.5)) - 0.4375) * 16, 0.0, 1.0);\n"
		"				factor = mix(factor, blend, weight);\n"
		"			}\n"
		"#endif\n"
		"		}\n"
		"		else\n"
		"		{\n"
		"			vec4 lightSpacePos2;\n"
		"			lightSpacePos2.xyz = lightSpacePos0.xyz + texMatrixScaleBias2.xyz;\n"
		"			lightSpacePos2.xy *= texMatrixScaleBias2.w;\n"
		"\n"
		"			if (lightSpacePos2.x > 0.01 && lightSpacePos2.y > 0.01 && lightSpacePos2.x < 0.99 && lightSpacePos2.y < 0.99)\n"
		"			{\n"
		"				factor = getShadowFactor(shadowTexture2, lightSpacePos2, shadowMapSize.z, invShadowMapSize.z,\n"
		"					fixedDepthBias.z, gradientScaleBias.z, shadowLightDotLN);\n"
		"\n"
		"#ifdef CASCADE_BLENDING\n"
		"				if (shadowCascadesCount > 3)\n"
		"				{\n"
		"					vec4 lightSpacePos3;\n"
		"					lightSpacePos3.xyz = lightSpacePos0.xyz + texMatrixScaleBias3.xyz;\n"
		"					lightSpacePos3.xy *= texMatrixScaleBias3.w;\n"
		"\n"
		"					float blend = getShadowFactor(shadowTexture3, lightSpacePos3, shadowMapSize.w, invShadowMapSize.w,\n"
		"						fixedDepthBias.w, gradientScaleBias.w, shadowLightDotLN);\n"
		"\n"
		"					float weight = clamp((max(abs(lightSpacePos2.x - 0.5), abs(lightSpacePos2.y - 0.5)) - 0.375) * 8, 0.0, 1.0);\n"
		"					factor = mix(factor, blend, weight);\n"
		"				}\n"
		"#endif\n"
		"			}\n"
		"			else\n"
		"			{\n"
		"				vec4 lightSpacePos3;\n"
		"				lightSpacePos3.xyz = lightSpacePos0.xyz + texMatrixScaleBias3.xyz;\n"
		"				lightSpacePos3.xy *= texMatrixScaleBias3.w;\n"
		"\n"
		"				factor = getShadowFactor(shadowTexture3, lightSpacePos3, shadowMapSize.w, invShadowMapSize.w,\n"
		"					fixedDepthBias.w, gradientScaleBias.w, shadowLightDotLN);\n"
		"\n"
		"				// Fade out to edges\n"
		"				float weight = clamp((max(abs(lightSpacePos3.x - 0.5), abs(lightSpacePos3.y - 0.5)) - 0.375) * 8, 0.0, 1.0);\n"
		"				factor = mix(factor, 1, weight);\n"
		"			}\n"
		"		}\n"
		"	}\n"
		"\n"
		"	return factor;\n"
		"}\n"
		"#endif\n"
		"#endif\n"
		"\n"
		"struct PBRInfo\n"
		"{\n"
		"	float NdotL;                  // cos angle between normal and light direction\n"
		"	float NdotV;                  // cos angle between normal and view direction\n"
		"	float NdotH;                  // cos angle between normal and half vector\n"
		"	float LdotH;                  // cos angle between light direction and half vector\n"
		"	float VdotH;                  // cos angle between view direction and half vector\n"
		"	float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n"
		"	float metalness;              // metallic value at the surface\n"
		"	vec3 reflectance0;            // full reflectance color (normal incidence angle)\n"
		"	vec3 reflectance90;           // reflectance color at grazing angle\n"
		"	float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n"
		"	vec3 diffuseColor;            // color contribution from diffuse lighting\n"
		"	vec3 specularColor;           // color contribution from specular lighting\n"
		"};\n"
		"\n"
		"const float M_PI = 3.141592653589793;\n"
		"const float c_MinRoughness = 0.04;\n"
		"\n"
		"vec4 SRGBtoLINEAR(vec4 srgbIn)\n"
		"{\n"
		"#ifdef MANUAL_SRGB\n"
		"#ifdef SRGB_FAST_APPROXIMATION\n"
		"	vec3 linOut = pow(srgbIn.xyz, vec3(2.2));\n"
		"#else //SRGB_FAST_APPROXIMATION\n"
		"	vec3 bLess = step(vec3(0.04045), srgbIn.xyz);\n"
		"	vec3 linOut = mix(srgbIn.xyz / vec3(12.92), pow((srgbIn.xyz + vec3(0.055)) / vec3(1.055), vec3(2.4)), bLess);\n"
		"#endif //SRGB_FAST_APPROXIMATION\n"
		"	return vec4(linOut, srgbIn.w);\n"
		"#else //MANUAL_SRGB\n"
		"	return srgbIn;\n"
		"#endif //MANUAL_SRGB\n"
		"}\n"
		"\n"
		"vec3 diffuse(PBRInfo pbrInputs)\n"
		"{\n"
		"	return pbrInputs.diffuseColor / M_PI;\n"
		"}\n"
		"\n"
		"vec3 specularReflection(PBRInfo pbrInputs)\n"
		"{\n"
		"	return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n"
		"}\n"
		"\n"
		"float geometricOcclusion(PBRInfo pbrInputs)\n"
		"{\n"
		"	float NdotL = pbrInputs.NdotL;\n"
		"	float NdotV = pbrInputs.NdotV;\n"
		"	float r = pbrInputs.alphaRoughness;\n"
		"\n"
		"	float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n"
		"	float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n"
		"	return attenuationL * attenuationV;\n"
		"}\n"
		"\n"
		"float microfacetDistribution(PBRInfo pbrInputs)\n"
		"{\n"
		"	float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n"
		"	float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n"
		"	return roughnessSq / (M_PI * f * f);\n"
		"}\n"
		"\n"
		"#ifdef USE_IBL\n"
		"vec3 getIBLContribution(PBRInfo pbrInputs, vec2 n)\n"
		"{\n"
		"	vec4 ibl = texture2D(u_DiffuseEnvSampler, n);\n"
		"	vec3 diffuseLight = SRGBtoLINEAR(ibl).rgb;\n"
		"	vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n"
		"	diffuse *= ibl.a;\n"
		"\n"
		"	return diffuse;\n"
		"}\n"
		"#endif\n"
		"\n"
		"#ifdef IS_SHADOW_CASTER\n"
		"float getShadow(vec3 objToLightDir, vec3 viewPos, vec3 normal)\n"
		"{\n"
		"	float shadow = 0.0;\n"
		"\n"
		"#if LIGHT_TYPE == LIGHT_DIRECTIONAL\n"
		"	float lDotN = dot(normal, objToLightDir);\n"
		"	vec3 worldPos = (invView * vec4(viewPos, 1)).xyz;\n"
		"	vec4 shadowProjPos = shadowViewProjMat * vec4(worldPos, 1);\n"
		"	shadowProjPos /= shadowProjPos.w;\n"
		"	shadow = getCsmShadowFactor(ShadowTex0, ShadowTex1, ShadowTex2, ShadowTex3, shadowProjPos, lDotN);\n"
		"#endif\n"
		"\n"
		"#if LIGHT_TYPE == LIGHT_SPOT\n"
		"	vec3 worldPos = (invView * vec4(viewPos, 1)).xyz;\n"
		"	vec4 shadowProjPos = shadowViewProjMat * vec4(worldPos, 1);\n"
		"	shadowProjPos /= shadowProjPos.w;\n"
		"\n"
		"	float pixeloffset = inverseShadowmapSize;\n"
		"\n"
		"	vec3 shadowUV = shadowProjPos.xyz;\n"
		"\n"
		"	float samples = shadowAASamples;\n"
		"	float offset = 0.1;\n"
		"	for (float x = -offset; x < offset; x += offset / (samples * 0.5))\n"
		"	{\n"
		"		for (float y = -offset; y < offset; y += offset / (samples * 0.5))\n"
		"		{\n"
		"			vec4 shadowData = texture(ShadowTex, shadowUV.xy + vec2(x, y) * 0.02);\n"
		"			float sampledDistance = shadowData.r;\n"
		"\n"
		"			shadow += (shadowData.x + fixedDepthBias > shadowUV.z) ? 1.0 : 0.0;\n"
		"		}\n"
		"	}\n"
		"	shadow /= (samples * samples);\n"
		"#endif\n"
		"\n"
		"#if LIGHT_TYPE == LIGHT_POINT\n"
		"	vec3 worldPos = (invView * vec4(viewPos, 1)).xyz;\n"
		"	vec3 lightDir = (worldPos - shadowCamPos);\n"
		"\n"
		"	float samples = shadowAASamples;\n"
		"	float offset = 0.1;\n"
		"\n"
		"	for (float x = -offset; x < offset; x += offset / (samples * 0.5))\n"
		"	{\n"
		"		for (float y = -offset; y < offset; y += offset / (samples * 0.5))\n"
		"		{\n"
		"			for (float z = -offset; z < offset; z += offset / (samples * 0.5))\n"
		"			{\n"
		"				vec4 shadowData = texture(ShadowTex, vec3(-lightDir.x, lightDir.y, lightDir.z) + vec3(x, y, z));\n"
		"				float sampledDistance = shadowData.r;\n"
		"\n"
		"				vec3 fromLightToFragment = lightPosWorld.xyz - worldPos;\n"
		"				float distanceToLight = length(fromLightToFragment);\n"
		"				float currentDistanceToLight = (distanceToLight - nearClipDistance) / (1000.0 - nearClipDistance);\n"
		"				currentDistanceToLight = clamp(currentDistanceToLight, 0, 1);\n"
		"\n"
		"				if (sampledDistance + fixedDepthBias > currentDistanceToLight)\n"
		"					shadow += 1.0;\n"
		"			}\n"
		"		}\n"
		"	}\n"
		"	shadow /= (samples * samples * samples);\n"
		"#endif\n"
		"\n"
		"	return shadow;\n"
		"}\n"
		"#endif\n"
		"\n"
		"void main()\n"
		"{\n"
		"	// None directional lights have some calculations to do in the beginning of the pixel shader\n"
		"#if LIGHT_TYPE != LIGHT_DIRECTIONAL\n"
		"	vec4 normProjPos = oPos / oPos.w;\n"
		"	// -1 is because generally +Y is down for textures but up for the screen\n"
		"	vec2 oUv0 = vec2(normProjPos.x, normProjPos.y * -1 * flip) * 0.5 + 0.5;\n"
		"	vec3 oRay = vec3(normProjPos.x, normProjPos.y * flip, 1) * farCorner;\n"
		"#endif\n"
		"\n"
		"	vec4 use_Lightmap = texture(u_LightMap, oUv0);\n"
		"	bool useLightmap = lightMode == 1 || (use_Lightmap.a == 1.0 && lightMode == 2);\n"
		"\n"
		"	vec4 a0 = texture(Tex0, oUv0); // Attribute 0: Diffuse color+shininess\n"
		"	vec4 a1 = texture(Tex1, oUv0); // Attribute 1: Normal+depth\n"
		"\n"
		"	// Attributes\n"
		"	float specularity = a0.a;\n"
		"	float distance = a1.w;  // Distance from viewer (w)\n"
		"	vec3 normal = a1.xyz;\n"
		"\n"
		"	if (distance == 0.0)\n"
		"		discard;\n"
		"\n"
		"	// Calculate position of texel in view space\n"
		"	vec3 viewPos = texture(u_ViewPos, oUv0).xyz;//normalize(oRay) * distance * farClipDistance;\n"
		"	float len_sq = 1.0;\n"
		"	float len = 1.0;\n"
		"\n"
		"	// Calculate light direction and distance\n"
		"#if LIGHT_TYPE == LIGHT_DIRECTIONAL\n"
		"	vec3 objToLightDir = -lightDir.xyz;\n"
		"#else\n"
		"	vec3 objToLightVec = lightPos.xyz - viewPos;\n"
		"	len_sq = dot(objToLightVec, objToLightVec);\n"
		"	len = sqrt(len_sq);\n"
		"	vec3 objToLightDir = objToLightVec / len;\n"
		"#endif\n"
		"\n"
		"	float final = 1.0;\n"
		"\n"
		"#ifdef IS_SHADOW_CASTER\n"
		"	final = getShadow(objToLightDir, viewPos, normal);\n"
		"#endif\n"
		"\n"
		"	float perceptualRoughness = u_MetallicRoughnessValues.y;\n"
		"	float metallic = u_MetallicRoughnessValues.x;\n"
		"\n"
		"#ifdef HAS_METALROUGHNESSMAP\n"
		"	// Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n"
		"	// This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n"
		"	float mrSample = texture(u_MetallicRoughnessSampler, oUv0).a;\n"
		"	perceptualRoughness = mrSample * perceptualRoughness;\n"
		"	metallic = mrSample * metallic;\n"
		"#endif\n"
		"\n"
		"	perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n"
		"	metallic = clamp(metallic, 0.0, 1.0);\n"
		"	// Roughness is authored as perceptual roughness; as is convention,\n"
		"	// convert to material roughness by squaring the perceptual roughness [2].\n"
		"	float alphaRoughness = perceptualRoughness * perceptualRoughness;\n"
		"\n"
		"	vec4 baseColor = vec4(0, 0, 0, 0);\n"
		"	if (!useLightmap)\n"
		"		baseColor = SRGBtoLINEAR(a0) * u_BaseColorFactor;\n"
		"\n"
		"	vec3 f0 = vec3(0.04);\n"
		"	vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n"
		"	diffuseColor *= 1.0 - metallic;\n"
		"	vec3 specularColor = mix(f0, baseColor.rgb, metallic) * lightSpecularColor.xyz;\n"
		"\n"
		"	float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n"
		"\n"
		"	float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n"
		"	vec3 specularEnvironmentR0 = specularColor.rgb;\n"
		"	vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n"
		"\n"
		"	vec3 n = normalize(a1.xyz);                             // normal at surface point\n"
		"	vec3 v = -normalize(viewPos);//              // Vector from surface point to camera\n"
		"	vec3 l = objToLightDir;//normalize(lightPos.xyz);             // Vector from surface point to light\n"
		"	vec3 h = normalize(l + v);                          // Half vector between both l and v\n"
		"	//vec3 reflection = -normalize(reflect(v, n));\n"
		"\n"
		"	float NdotL = clamp(dot(n, l), 0.001, 1.0);\n"
		"	float NdotV = abs(dot(n, v)) + 0.001;\n"
		"	float NdotH = clamp(dot(n, h), 0.0, 1.0);\n"
		"	float LdotH = clamp(dot(l, h), 0.0, 1.0);\n"
		"	float VdotH = clamp(dot(v, h), 0.0, 1.0);\n"
		"\n"
		"	PBRInfo pbrInputs = PBRInfo(\n"
		"		NdotL,\n"
		"		NdotV,\n"
		"		NdotH,\n"
		"		LdotH,\n"
		"		VdotH,\n"
		"		perceptualRoughness,\n"
		"		metallic,\n"
		"		specularEnvironmentR0,\n"
		"		specularEnvironmentR90,\n"
		"		alphaRoughness,\n"
		"		diffuseColor,\n"
		"		specularColor\n"
		"	);\n"
		"\n"
		"	// Calculate the shading terms for the microfacet specular shading model\n"
		"	vec3 F = specularReflection(pbrInputs);\n"
		"	float G = geometricOcclusion(pbrInputs);\n"
		"	float D = microfacetDistribution(pbrInputs);\n"
		"\n"
		"	// Calculation of analytical lighting contribution\n"
		"	vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n"
		"	vec3 specContrib = (F * G * D / (4.0 * NdotL * NdotV)) * a0.w;\n"
		"	vec3 color = NdotL * lightDiffuseColor.xyz * (diffuseContrib + specContrib);\n"
		"\n"
		"#ifdef USE_IBL\n"
		"	color += getIBLContribution(pbrInputs, oUv0);\n"
		"#endif\n"
		"\n"
		"	// Apply optional PBR terms for additional (optional) shading\n"
		"#ifdef HAS_OCCLUSIONMAP\n"
		"	vec4 ao = texture(u_OcclusionSampler, oUv0);\n"
		"	color = mix(color, color * ao.r, ao.a);\n"
		"#endif\n"
		"\n"
		"	vec4 pbr_FragColor = vec4(pow(color, vec3(1.0 / 2.2)), baseColor.a);\n"
		"\n"
		"#if IS_ATTENUATED\n"
		"	//Compute attenuation value\n"
		"	float att = 1.0;\n"
		"	if (lightPos.w > 0.0)\n"
		"	{\n"
		"		att = smoothstep(lightFalloff.x, 0.0, len) * lightPower;\n"
		"	}\n"
		"	else\n"
		"	{\n"
		"		att = lightPower;\n"
		"	}\n"
		"\n"
		"	pbr_FragColor *= att;\n"
		"\n"
		"#endif\n"
		"\n"
		"#if LIGHT_TYPE == LIGHT_SPOT\n"
		"	float spotlightAngle = clamp(dot(lightDir.xyz, -objToLightDir), 0.0, 1.0);\n"
		"	float spotFalloff = clamp((spotlightAngle - spotParams.x) / (spotParams.y - spotParams.x), 0.0, 1.0);\n"
		"	pbr_FragColor *= (1.0 - spotFalloff);\n"
		"#endif\n"
		"\n"
		"	//fragColour = vec4((spec + (total_light_contrib * colour)) * final, 0.0);\n"
		"	fragColour = vec4(pbr_FragColor.xyz * final, 0.0);\n"
		"	//----------------------------------------------------------------------------------------\n"
		"}";